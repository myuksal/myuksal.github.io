# 이더리움 PoS 합의 알고리즘의 Geth 및 Reth 구현 분석

## 목차

1. **이더리움 PoS 합의 알고리즘 개요**
2. **Geth 클라이언트에서의 PoS 합의 구현**

   - 2.1 포크 선택 규칙 처리 (Fork Choice Rule)
   - 2.2 체인 재구성 (Reorg) 처리
   - 2.3 에포크 및 슬롯 관리
   - 2.4 RANDAO 관련 로직

3. **Reth 클라이언트에서의 PoS 합의 구현**

   - 3.1 포크 선택 규칙 처리 (Fork Choice Rule)
   - 3.2 체인 재구성 (Reorg) 처리
   - 3.3 에포크 및 슬롯 관리
   - 3.4 RANDAO 관련 로직

4. **Geth vs Reth: 구조상의 차이점과 공통점 요약**

## 1. 이더리움 PoS 합의 알고리즘 개요

이더리움은 **Beacon 체인** 기반의 **지분증명(Proof of Stake, PoS)** 합의 알고리즘을 사용함.
합의 프로토콜에는 **에포크(epoch)**와 **슬롯(slot)** 개념이 있음.
**1개 에포크는 32개 슬롯** (약 6.4분)으로 구성되고 **1개 슬롯은 12초**.
각 슬롯마다 네트워크의 검증인(validator) 중 한 명이 **블록 제안자**로 무작위 선택되어 블록을 제안하고, 나머지 검증인들은 해당 슬롯의 블록에 대한 **승인 투표(attestation)**를 함.
빈 슬롯도 발생할 수 있으며, 이 경우 체인은 다음 슬롯으로 넘어감.
빈 슬롯은 컴퓨터가 맛탱이 가거나 네트워크 지연으로 차질이 생기는 경우.

PoS 합의의 **포크 선택 규칙**은 **LMD-GHOST**(Latest Message Driven - Greediest Heaviest Observed SubTree) 알고리즘과 **Casper FFG** 최종화(finality) 알고리즘을 돌림.
**검증인들의 최신 투표 메시지에 기반하여 가장 무거운 서브트리를 선택**하는 LMD-GHOST를 사용하되, **마지막으로 최종화된 체크포인트 블록의 자손들만 유효한 후보로 간주**하도록 Casper FFG 규칙이 LMD-GHOST를 제약함. (Casper FFG 가 LMD-GHOST에게 자중해! 를 시전함)
Casper FFG의 투표를 통해 에포크 단위로 **블록의 정당성(Justification)과 최종성(Finalization)**이 확보.
한 번 **최종화(finalized)**된 블록 이전의 체인 분기는 영구적으로 포크 선택 대상에서 제외.
**최종화된 체크포인트 이후 구간에서는 LMD-GHOST에 따라 현재 가장 높은 투표 가중치를 지닌 체인 헤드가 선택.**
이러한 구조 덕분에 PoS 이더리움은 **체인 재구성 깊이(reorg depth)**가 제한됨 (최종화된 블록 이전으로는 재구성 불가).

**랜덤 비콘(randomness beacon)**으로서 **RANDAO** 메커니즘을 사용.
각 슬롯의 블록 제안자는 자신의 개인키로 현재 에포크 번호에 서명한 값을 **Randao 리빌(reveal)**로 블록에 포함, 이를 Beacon 체인이 누적하여 난수 시드(seed)를 생성.
**블록 제안자의 Randao 서명이 올바르지 않으면 블록은 무효**.
수집된 난수는 다음 에포크의 검증인 셔플링 등에 활용.
PoS 이더리움 Merge 이후 실행층(EVM)에서도 이 Randao 값을 활용할 수 있도록 합의가 변경됨? (각 클라이언트의 **RANDAO 구현 로직**에서 자세히 설명)

> **이더리움 PoS 합의 알고리즘**은 Beacon 체인의 **슬롯/에포크 스케줄**에 따라 **검증인들이 블록 제안 및 투표**를 수행
> **Casper FFG**로 **최종성**을 부여
> **LMD-GHOST**로 **비최종화 구간의 최상위 체인 헤드**를 선택

## 2. Geth 클라이언트에서의 PoS 합의 구현

### 2.1 포크 선택 규칙 처리 (Fork Choice Rule in Geth)

Geth는 **실행 클라이언트(Execution Client)**로서, PoS 합의 프로토콜의 **포크 선택 결과**를 **엔진 API**를 통해 **컨센서스 클라이언트**로부터 전달받아 처리.
Merge 이후 Geth에는 `engine_forkchoiceUpdated` 등의 엔진 API RPC 핸들러가 추가됨, Beacon 체인 합의로 새로운 체인 헤드를 선택할 때 이를 받아들여 **체인 상태를 전환**.
wGeth 소스코드에서는 `eth/catalyst/api.go` 모듈의 `ConsensusAPI` 구조체에 이러한 엔진 API 핸들러들이 구현되어 있음.

예를 들어 `ConsensusAPI.ForkchoiceUpdatedV1(...)` 메서드는 컨센서스 레이어로부터 **포크 선택 상태와 신규 페이로드 지시를 입력받아**, 내부적으로 `api.forkchoiceUpdated(...)` 함수를 호출, Geth의 체인 헤드를 갱신하고 (필요시) 블록 생성 프로세스를 시작.

Geth는 **포크 선택(Fork Choice)** 처리를 위해 **ForkChoice 구조체**를 도입하여 체인 헤드 전환을 관리함.
`core.BlockChain` 구조체는 `forker` 필드로 `ForkChoice` 인스턴스를 유지하며, Geth 실행 시 `NewForkChoice(bc, preserveFunc)`를 호출하여 이를 초기화.
이 `ForkChoice`는 현재 체인의 정보(`ChainReader` 인터페이스)와 블록 보존 조건 함수(`preserve` 함수)를 받아 구성됨.

핵심 메서드로 `ReorgNeeded()`를 제공.
`ForkChoice.ReorgNeeded(current *types.Header, extern *types.Header) (bool, error)`는 **현재 캐노니컬 헤드**(current)와 **외부에서 제시된 새로운 헤드**(extern)를 비교하여 **체인 재구성(reorg)**이 필요한지 여부를 판단.
extern 헤더가 현재 체인의 연장선에 있는 경우 단순 연장, extern이 다른 분기를 나타낼 경우 `true`를 리턴. (재구성 해야됨을 알림)
extern 헤더가 DB에 없는 등 **맛탱이가 간 경우 에러**를 리턴.
에러가 나면 Geth가 컨센서스 레이어에 **동기화 필요**(SYNCING 상태)를 응답.
Geth의 forkchoice 처리 로직은 이러한 `ReorgNeeded` 결과를 토대로, 필요시 체인 재구성을 수행하고 새로운 헤더를 캐노니컬 헤드로 **승격**시킴.

Geth 엔진 API에서 **컨센서스 클라이언트가 전달한 포크 선택 상태**를 수신하면

- 해당 **헤드 블록 해시**가 가리키는 블록을 자체 DB에서 조회
- 블록이 이미 삽입되어 있다면(예: 이전에 `engine_newPayload`를 통해 검증/저장 완료), 곧바로 `ForkChoice`를 활용해 현재 헤드와 비교한 뒤 **체인 헤드 포인터를 갱신**
- 반면 블록 정보가 없다면 컨센서스 쪽에 **동기화 필요**(SYNCING 상태)를 보고하고, 필요한 페이로드들을 받아와 **블록을 저장한 후 헤드를 갱신**

_Geth는 forkchoice 업데이트 처리 과정에서 **안전 헤드(safe block)**와 **최종화된 블록(finalized block)** 정보도 함께 제공받음_

> **Geth는 PoS의 포크 선택 알고리즘 자체(LMD-GHOST)는 구현하지 않지만** > **Engine API를 통해 전달된 최종 포크 선택 결과를 반영**하여 **현재 체인 헤드**를 전환하고
> 필요 시 **새 블록을 빌드**하거나 **동기화**함

### 2.2 체인 재구성 (Reorg) 처리 in Geth

체인 **재구성(reorganization)**이란 현재 선택된 캐노니컬 체인을 **다른 분기로 변경**하는 과정.
앞서 언급한 `ForkChoice` 모듈과 기존의 체인관리 코드를 활용하여 reorg를 처리함.

`core.BlockChain` 구조체는 블록을 DB에 저장하고 체인 상태를 관리. `SetHead`/`SetFinalized` 등의 함수와 **reorg 시 분기 정리** 로직이 구현됨.
예를 들어 `BlockChain.SetFinalized(header)`는 주어진 헤더를 **최종화 블록**으로 설정하면서, 해당 블록보다 이전의 모든 분기 데이터를 정리함.
마찬가지로 `BlockChain.SetSafe(header)`는 **안전 블록(safe head)**를 설정하여 체인 재구성 한계를 표시함.
Engine API 처리 루틴에서, 컨센서스 클라이언트가 전달한 finalized 블록 및 safe 블록 해시를 실제 헤더로 찾아 설정하는데 사용됨.

reorg 발생 시

- **공통 조상 블록(common ancestor)**을 찾음
- 기존 체인의 해당 조상 이후 블록들을 **캐노니컬 체인에서 제거**
- 신규 체인의 블록들을 **캐노니컬 체인으로 편입**
- **ChainHeadEvent**와 **ChainSideEvent** 등을 발생시켜 상위 모듈에 체인 전환을 알림
- 트랜잭션 풀 등 부가 구성요소를 업데이트
- `ForkChoice.ReorgNeeded(...)`가 `true`를 반환하면, Geth는 일반적으로 새로운 헤더를 현재 헤드로 만들기 위해 `BlockChain` 내부에서 재구성

**최종화된 블록** 이전으로의 reorg가 불가능하도록 보장되므로, Geth는 reorg 시 항상 **최종화 지점 이후**의 블록들만 대체함.
`currentFinalBlock`과 `currentSafeBlock` 포인터를 관리하면서, reorg하려는 새로운 헤드가 이들 제약을 어기는지 검사.
만약 컨센서스 레이어로부터 전달된 새로운 헤드가 `currentFinalBlock` 이전의 분기를 가리킨다면 오류로 처리 (컨센서스가 똑바로 만들어져있다면 이런거 구경도 못함).

- **엔진 API**로 새 헤드 제시 -> `ForkChoice.ReorgNeeded`로 기존 헤드와 비교 -> reorg 필요 시
- **공통 조상** 이후 기존 canonical 체인의 블록들을 사이드 체인으로 보내고 (`ChainSideEvent` 발생)
- 새로운 분기의 블록들을 canonical 체인으로 채택 (`ChainHeadEvent` 발생)
- **currentBlock** (헤드), **currentFinalBlock**, **currentSafeBlock** 등을 갱신하고 DB에 저장
- 관련 캐시 및 트랜잭션풀 정리

### 2.3 에포크 및 슬롯 관리 in Geth

PoS 합의에서 **슬롯과 에포크** 개념은 주로 **컨센서스 클라이언트 측**에서 관리됩니다. 실행 클라이언트인 Geth는 슬롯/에포크를 깊이 있게 알 필요는 없지만, **블록 타임스탬프, 최종화 시점, 안전 블록** 등을 통해 간접적으로 그 개념을 반영합니다.

Geth는 **각 블록의 타임스탬프**가 Beacon 체인의 슬롯 시간(12초 간격)에 부합하는지를 검증합니다. Merge 이후 **블록 간 난이도**가 0으로 고정되면서 (PoW 난이도 폐지) **타임스탬프 순증 요건**만 검증하면 되므로, Geth의 `VerifyHeader` 구현은 **부모보다 시간이 같거나 과거인 블록을 거부**하여 슬롯 질서를 강제합니다. 별도로 "이 타임스탬프가 정확히 12초 단위로 증가해야 한다"는 규칙은 실행 클라이언트에서 강제하지는 않는데, 이는 컨센서스 층이 슬롯 번호에 따라 타임스탬프를 지정해주므로 실행층은 **단조 증가 여부만 확인**하면 충분하기 때문입니다.

**에포크(epoch)**와 관련해서, Geth는 **최종화(finalization)** 개념을 통해 에포크 경계를 인식합니다. Casper FFG에 의해 매 에포크마다 하나의 체크포인트 블록이 최종화될 수 있는데, 컨센서스 클라이언트는 이 정보를 엔진 API `ForkchoiceUpdated` 호출 시 제공해줍니다. Geth는 `ForkchoiceUpdated` 파라미터로 받은 `finalizedBlockHash`를 처리하여 해당 블록을 DB에서 찾아 **현재 최종화 블록**으로 설정합니다. Geth `BlockChain.SetFinalized(header)` 함수는 이 작업을 수행하며, 최종화 블록을 업데이트하고 관련 메트릭(`headFinalizedBlockGauge`)도 갱신합니다. Geth는 이 최종화 블록을 디스크에 기록해 두고 (`rawdb.WriteFinalizedBlock` 등을 통해), 재기동 시 불러옵니다.

또한 컨센서스 레이어는 **안전 헤드(safe head)**라는 개념도 전송하는데, 이는 최종화보다 느슨하지만 경제적으로 뒤집히기 어렵다고 간주되는 헤드입니다. Geth는 `ForkchoiceUpdated` 입력의 `safeBlockHash`를 받아 동일하게 처리하며, `BlockChain.SetSafe(header)`를 호출해 안전 블록으로 설정합니다. 안전 블록과 최종화 블록 정보는 Geth 체인의 상태를 나타내는 중요한 지표로서, JSON-RPC (`eth_syncing` 등)에서도 활용됩니다. 예컨대 Geth 1.10.21 이후로 `eth_syncing` 결과에 `currentSafeBlock`과 `currentFinalizedBlock` 필드가 추가되어, 동기화 상황에서 해당 블록 넘버를 보고할 수 있습니다.

정리하면, Geth는 **슬롯** 자체를 직접 관리하진 않지만 **블록의 시간/높이 관리**를 통해 슬록 흐름을 따르고, **에포크** 개념은 **최종화 블록** 처리를 통해 반영합니다. 최종화 블록 갱신은 곧 에포크 단위의 체크포인트 확정과 같으며, Geth는 이를 체인 DB와 메모리에 저장해 두어 이후 **상태(pruning 등)** 관리에 활용할 수 있습니다. 또한 Geth는 최종화 블록 이전의 데이터(예: 트랜잭션 응답 캐시 등)를 안전하게 정리(truncate)할 수 있는데, 이는 최종화된 부분은 되돌리지 않으므로 장기 데이터 정리에 이용됩니다.

### 2.4 RANDAO 관련 로직 in Geth

**RANDAO**는 이더리움 PoS에서 난수를 축적하는 방식으로, **블록 헤더에 포함되는 값**을 통해 구현됩니다. **Merge 이후 이더리움 실행 블록 헤더의 `mixHash` 필드**(PoW 때는 채굴 시 사용되던 필드)가 **Beacon 체인으로부터 전달된 난수 (PrevRandao)**로 채워지도록 재활용되었습니다. 또한 **블록 난이도(difficulty) 필드**는 항상 0으로 설정되어 더 이상 사용되지 않습니다. 다시 말해, **Geth는 각 PoS 블록 헤더의 `MixDigest`(mixHash) 자리에 해당 슬롯의 Randao 난수를 저장**하며, EVM에서 이를 참조할 수 있게 합니다.

이 변경은 **EIP-4399 (PREVRANDAO)**에 명시되어 있으며, 기존 EVM의 `DIFFICULTY`(opcode 0x44) 연산을 **`PREVRANDAO`**로 재정의하는 방식으로 구현되었습니다. Geth의 EVM 구현인 `core/vm` 패키지에서는 0x44 연산 코드를 `PREVRANDAO`로 명명하고, **현재 블록 헤더의 prevRandao 값을 반환**하도록 변경했습니다. 그 결과 컨트랙트에서 Solidity 0.8.18 이상의 `block.prevrandao`를 호출하면 Beacon 체인이 제공한 난수를 얻을 수 있습니다. (기존 `block.difficulty`도 하위호환성을 위해 동일한 값을 반환하지만, 개념적으로는 더 이상 난이도가 아니므로 새 이름을 사용합니다.)

Geth에서 **Randao 값의 처리**는 주로 **블록 생성 또는 검증 시** 이루어집니다. 컨센서스 클라이언트가 `engine_preparePayload`/`engine_forkchoiceUpdated` 호출을 통해 새로운 블록 제작을 요청할 때, 파라미터로 `prevRandao` 값이 포함됩니다. Geth의 해당 처리 루틴은 이 값을 새로운 블록 헤더의 `MixDigest` 필드에 채워 넣습니다. 이후 블록이 최종 생성될 때 (`FinalizeAndAssemble` 단계), 이 `MixDigest` 값이 상태트리에 영향을 주는 것은 아니지만, **EVM의 블록 컨텍스트에 포함**되어 OPCODE 연산의 입력으로 사용됩니다.

블록 검증 측면에서, Geth의 `BeaconConsensus.VerifyHeader` 구현은 **PoS 블록의 경우 난이도 필드가 0인지, mixHash 필드가 임의의 32바이트 값으로 존재하는지** 등을 확인합니다. 별도로 Geth가 이 mixHash(prevRandao) 값의 진위를 독립적으로 검증할 수는 없습니다. Randao 값은 Beacon 체인 상태에 따른 것이므로, **컨센서스 클라이언트가 올바른 서명 검증을 통해 보증**하며, Geth는 해당 값을 신뢰하여 저장만 합니다. 따라서 Geth 입장에서는 **난수 값의 존재 여부 및 형식**만 체크하고 (`Header.MixDigest`가 nil이 아닌지 등) 블록 해시에 포함시킬 뿐, 추가 검증은 수행하지 않습니다.

정리하면, Geth의 RANDAO 관련 구현은 **헤더 구조와 EVM 연산 변경**으로 요약할 수 있습니다:

- 블록 헤더 구조: PoS 모드에서 `Header.MixDigest` 필드를 **`prevRandao` 값 저장용**으로 사용.
- 블록 OPCODE: 0x44 (`DIFFICULTY`)를 `PREVRANDAO`로 간주하여 헤더의 해당 필드 값을 반환.
- 블록 생성 시: 컨센서스 층이 제공한 난수를 헤더에 설정 (예: Geth JSON-RPC 엔진 API 구현에서 payloadAttributes.prevRandao를 헤더에 세팅).
- 블록 검증 시: 난이도=0, mixHash 필드 존재 여부 등의 체크로 충분 (자체 난수 검증은 컨센서스에 위임).

이러한 변경으로, **Merge 이후 이더리움에서 난수 접근이 보다 강력해졌으며** (이전 PoW의 `block.difficulty`는 예측 가능성이 높았으나, 이제 `block.prevrandao`는 Beacon 체인의 집단 서명 기반 난수여서 더 안전), Geth는 이를 충실히 지원하도록 코드가 업데이트되었습니다.

## 3. Reth 클라이언트에서의 PoS 합의 구현

Paradigm의 **Reth**는 Rust로 작성된 실행 클라이언트로, Geth와 유사한 역할을 수행합니다. Reth는 개발상 비교적 최신 구조를 가지며, PoS 합의와 Execution Engine의 인터페이스를 모듈화하여 구현했습니다. 전체적으로 **엔진 API** 구현, **블록체인 트리 관리**, **상태/저장소 모듈** 등이 Rust 크레이트로 나뉘어 있습니다. 아래에서는 Reth에서 Geth와 대응되는 각 항목별 구현을 살펴봅니다.

### 3.1 포크 선택 규칙 처리 (Fork Choice Rule in Reth)

Reth 역시 실행 클라이언트로서 **컨센서스 클라이언트**와의 엔진 API 통신을 통해 포크 선택 결과를 전달받습니다. Reth 코드베이스에서는 `reth_rpc_engine_api` 크레이트에 이러한 RPC 핸들러들이 정의되어 있습니다. 예를 들어 Reth의 엔진 API 서비스는 `EngineApi` 구조체에 `fork_choice_updated_v2(&self, state: ForkchoiceState, payload_attrs: Option<PayloadAttributes>) -> ForkchoiceUpdated` 함수로 구현되어 있습니다. 이 핸들러는 호출을 받으면 내부적으로 **`EngineApi::fork_choice_updated_v2` 비동기 함수**를 호출하고, 곧바로 **Beacon Engine 작업(task)**에 `ForkchoiceUpdated` 메시지를 보냅니다. Reth는 Tokio 기반 비동기 아키텍처를 활용하므로, 엔진 API 호출은 즉각 결과를 반환하지 않고 이벤트로 엔진 태스크에 전달되어 처리됩니다.

구체적으로, Reth의 **컨센서스 엔진**은 `reth_consensus::beacon` 크레이트에 구현되어 있으며, 여기서 **비콘 엔진 태스크**가 별도 스레드/태스크로 동작합니다. 위에서 언급한 `BeaconEngineMessage::ForkchoiceUpdated` 이벤트를 받으면, 엔진 태스크는 전달받은 forkchoice 상태를 해석하여 다음과 같은 작업을 수행합니다:

- **신규 헤드 해시**가 제시된 경우, 해당 블록이 체인에 있는지 확인하고 없으면 블록 동기화/요청을 처리합니다.
- 블록이 이미 저장되어 있다면, 이를 **블록체인 트리**에 추가/업데이트하고 현재 **캐노니컬 헤드**를 이 블록으로 설정할지 결정합니다.
- `ForkchoiceState`에 포함된 `finalized_block_hash`나 `safe_block_hash`를 처리하여, 체인 트리에 최종화/안전 지점을 반영합니다.

Reth의 중요한 구성요소는 **`blockchain-tree` 크레이트**로, 이는 체인의 여러 분기를 관리하고 현재 canonical 체인을 결정하는 로직을 담고 있습니다. Geth의 `ForkChoice`+`BlockChain` 조합과 달리, Reth는 블록 트리를 명시적으로 표현하여, **동시에 여러 포크를 메모리에 보관**하고, `forkchoiceUpdated` 이벤트가 올 때마다 **캐노니컬 체인을 변경**하거나 **분기를 병합**합니다. 이는 Reth가 **비동기 실행**과 **병렬 처리**를 고려한 설계로, 예를 들어 블록들이 동시에 도착하거나 여러 분기를 탐색하는 시나리오에 대응하기 쉽습니다.

Reth의 fork choice 처리 흐름은 Pangea 재단의 블로그 설명으로 잘 나타나 있습니다:

> _"이 호출은 BeaconEngineMessage::ForkchoiceUpdated 이벤트를 consensus/beacon/src/engine의 엔진 태스크에 보내며, 엔진 태스크는 채굴된 블록(또는 받은 새 블록)을 체인에 추가한다. 만약 경쟁하는 블록(즉, 포크)이 있을 경우 재구성을 고려하여 canonical 체인을 수정해야 한다. 이러한 로직 대부분은 `blockchain-tree` 크레이트에 구현되어 있다"_.

위와 같이, Reth는 엔진 API를 통해 입력된 fork choice 신호를 **blockchain-tree** 모듈로 보내어 **캐노니컬 체인(head) 결정**과 **포크 보관/정리**를 수행합니다. 최종적으로 엔진 API 호출에 대한 응답(`ForkchoiceUpdated` 응답 객체)을 작성하여 컨센서스 클라이언트에 돌려줍니다. 이 응답에는 현재 상태 (`SUCCESS`/`SYNCING` 등)와 payload 준비 여부 등이 포함됩니다.

Reth는 자체적으로 합의 알고리즘(LMD-GHOST/FFG)을 구현하지는 않지만, **컨센서스 클라이언트 없이 단독 실행(예: `--auto-mine` 옵션)**할 경우를 대비한 **`auto-seal` 모드**를 제공합니다. auto-seal 모드에서는 Reth가 **간이 PoS 합의**를 흉내 내어 새 트랜잭션이 들어올 때 자동으로 블록을 생성합니다. 이때 forkchoiceUpdated 이벤트는 내부적으로도 발생하여, 하나의 클라이언트 내에서 "컨센서스" 역할을 일부 수행합니다. 그러나 이 경우에도 복잡한 LMD-GHOST를 구현하기보다는 단일 노드이므로 곧바로 블록을 head로 채택하는 단순한 로직입니다.

정리하면, **Reth의 포크 선택 처리**는:

- **reth_rpc_engine_api**: 엔진 API RPC 수신 (`forkchoiceUpdatedV2` 등).
- **EngineApi**: 입력을 받아 **BeaconEngineMessage**로 변환 후 **엔진 태스크**로 전달.
- **reth_consensus_beacon**: 엔진 태스크에서 **blockchain-tree**를 통해 블록 추가/헤드선택 수행.
- **결과 응답**: ForkchoiceUpdated 응답 객체 생성하여 반환.

이러한 계층 분리는 Geth보다 구조적으로 명확하며, Rust의 `Future`/채널 등을 통해 구현되어 있습니다.

### 3.2 체인 재구성 (Reorg) 처리 in Reth

Reth에서 체인 재구성은 주로 앞서 언급한 **`blockchain-tree`** 모듈에서 처리됩니다. `blockchain-tree`는 DB에 저장된 블록들을 기반으로 **포크들(브랜치)**을 관리하며, **canonical**(정식 체인)과 **pending branches**를 추적합니다. 포크 선택 업데이트가 도착하면, `blockchain-tree`는:

- 새로운 헤드 해시가 속한 분기를 식별하고,
- 그 분기를 canonical로 **승격**시킵니다.
- 이 과정에서 이전 canonical 분기는 pending 상태로 내려가며 (필요시 유지 또는 제거),
- 최종화/안전 블록 기준으로 불필요해진 오래된 분기는 pruning 됩니다.

Reth의 `BlockchainTree` 구조체 (또는 유사한 이름의 구조)가 이러한 로직을 캡슐화하고 있으며, `set_canonical_head`와 같은 메서드로 구현되어 있을 것으로 추정됩니다. (Rust 문서상 `BlockchainTree::make_canonical(hash)` 등의 함수가 존재할 수 있습니다.) Reth 공식 문서를 보면 **“advancing a reth chain”**에 관한 내용이 기술되어 있는데, 이는 체인 헤드를 바꾸는 reorg를 의미합니다. 또한 Reth 이슈 트래커에서도 `finalize_block`을 호출하여 finalized 변경 시 체인 데이터를 처리하는 내용이 나타납니다. 이로 미루어, Reth는 최종화 블록이 변할 때 블록트리에 해당 표시를 하고, 거기까지의 사이드 체인을 정리하는 것으로 보입니다.

Reth에서 **체인 재구성 이벤트**는 Geth처럼 명시적인 Event로 노출되기도 합니다. Reth `providers` 모듈의 `BlockchainProvider` 인터페이스에 **포크choice 알림 (ForkChoiceSubscriptions)**이 있어, 새로운 canonical 헤드나 finalized 블록이 선택될 때 구독자에게 알릴 수 있습니다. 이를 통해 Reth 내의 다른 서비스 (예: JSON-RPC `eth_subscribe` 구현 등)가 **체인 헤드 변경**을 감지합니다.

기술적으로, Reth의 reorg 처리 절차는 다음과 같이 요약할 수 있습니다:

- **새 헤드 지정**: blockchain-tree에서 주어진 블록 해시를 canonical head로 설정.
- **공통 조상 처리**: 이전 head와 새 head 사이의 fork 공통 조상을 계산.
- **상태 업데이트**: 공통 조상 이후의 상태를 새 head 기준으로 적용. Reth는 실행엔진으로 **REVM**을 사용하며, 상태 트리는 fork 간에 공유/복사되기보다 **지연(eager)** 적용과 **revert**를 조합해 관리합니다. (세부적으로, Reth는 **메모리상의 여러 State snapshot**을 관리하거나, 필요시 디스크에서 state root를 불러오는 방식으로 fork간 상태를 관리할 가능성이 있습니다.)
- **이전 canonical 분기 처리**: 필요시 이전 헤드 분기를 pending으로 두거나, 최종화된 블록 아래라면 완전히 삭제.
- **메트릭 업데이트**: 새로운 head 번호, finalized/safe 번호 등을 갱신.

Reth의 Rust 모듈은 이러한 처리를 함수 단위로 잘라 두었을 것입니다. (예: `fn apply_forkchoice(&mut self, state: ForkchoiceState) -> Result<..>` 등이 존재할 수 있음.)

Pangea 블로그에 따르면 **"만약 경쟁하는 블록으로 인한 re-org가 발생하면 canonical 체인의 개념을 수정해야 한다"**고 언급되어 있으며, **이 로직이 blockchain-tree에 많이 들어있다**고 설명합니다. 따라서 Reth에서는 재구성의 핵심이 blockchain-tree 크레이트로 모듈화되어, Geth의 `ForkChoice.ReorgNeeded`에 대응하는 역할을 하고 있다고 볼 수 있습니다.

### 3.3 에포크 및 슬롯 관리 in Reth

Reth도 Geth와 마찬가지로 **슬롯/에포크 관리의 주체는 컨센서스 클라이언트**이며, Reth 자체는 그것을 직접 구현하지 않습니다. 그러나 Reth는 **엔진 API 입력**을 통해 전달되는 **최종화 블록, 안전 블록 정보**를 처리함으로써 에포크 경계를 인지합니다.

Reth의 `BlockchainProvider` (및 내부의 `CanonChainTracker` 구현)은 **현재 안전 블록과 최종화 블록을 조회/설정**하는 인터페이스를 노출합니다. Rust 문서에 따르면:

- `fn finalized_block_number() -> Option<u64>` 및 `fn finalized_block_hash() -> Option<H256>` 메서드로 **최종화 블록 번호와 해시를 조회**할 수 있고,
- `fn set_finalized(header: SealedHeader) -> ()` 메서드로 **최종화 블록을 설정**할 수 있습니다.
- 유사하게 `safe_block_hash`/`safe_block_number` 접근자나 `set_safe(...)` 메서드도 있을 것으로 예상됩니다 (문서에는 safe 관련 메서드도 있지만 일부분만 나타나 있음).

이러한 메서드들은 결국 `blockchain-tree` 혹은 chain DB에 연결되어, Reth 엔진이 forkchoiceUpdated 시 받은 finalized/safe 정보를 반영합니다. 예를 들어 `EngineApi::fork_choice_updated_v2` 처리 코드 내에서, `forkChoiceState.finalizedBlockHash`가 Some(hash)로 지정돼 있으면 해당 해시를 블록트리에서 찾아 `set_finalized(header)`를 호출할 것입니다. Reth는 이때 **데이터베이스 트랜잭션**을 통해 finalized 상태를 기록할 가능성이 높습니다 (Geth처럼). 실제로 Reth GitHub 이슈 중 `call finalize_block when finalized block changes`라는 것이 있는데, 이는 최종화 블록 변경 시 `finalize_block` 함수를 호출하도록 한 패치입니다. 해당 함수는 DB상의 finalized marker를 업데이트하고, 필요하면 **상태 trie 스냅샷을 정리**하거나 **체인 pruning**을 수행할 것입니다.

**슬롯** 관련해서는, Reth는 기본적으로 컨센서스에서 슬롯당 요청을 받으면 **payloadAttributes.timestamp**를 통해 슬롯 시간(Unix 시간)을 부여받습니다. Reth 내부적으로 **블록 헤더 생성 시** 이 타임스탬프를 그대로 사용하며, Geth와 동일하게 부모 블록보다 커야 함을 검증합니다. Reth의 REVM 실행 컨텍스트에는 `Env` 구조체로 타임스탬프 등을 전달하며, 12초 배수가 아니어도 무방하나, 컨센서스가 올바른 슬롯 시간만 보내므로 문제가 없습니다.

Reth는 자체적으로 Beacon 노드를 대체하지 않으므로, **에포크 번호**를 계산하거나 검증하는 로직은 없습니다. 다만 **Randao**값 계산을 위해서 (예: 다음 subsection) 슬롯/에포크 정보가 약간 관여할 뿐입니다. 또한 Reth는 Geth의 blsync와 유사하게 **경량 Beacon 클라이언트 모드**는 아직 (2025년 초 기준) 지원하지 않는 것으로 보입니다.

정리하면, **Reth의 에포크/슬롯 관리**는:

- **최종화/안전 블록 관리**: `set_finalized`, `set_safe` 메서드를 통해 에포크 경계(최종화 시점)를 표시. 이로써 finality 보장.
- **블록 타임스탬프 검증**: 컨센서스 입력에 의존. Reth `HeaderValidator`가 부모 대비 timestamp 증가만 체크.
- **메트릭/구독**: `subscribe_finalized_block()` 등을 통해 최종화 블록 변경 이벤트를 구독 가능.

### 3.4 RANDAO 관련 로직 in Reth

Reth의 RANDAO 처리도 Geth와 마찬가지로 **블록 헤더 필드와 EVM opcode 처리** 측면에서 이루어집니다. Rust 구현체인 Reth에서는 블록 헤더 구조가 `reth_primitives` 크레이트에 정의되어 있는데, Ethereum 블록 헤더의 필드에 **prev_randao**가 포함되어 있습니다. 실제로 Reth CLI 도구를 보면 `reth debug build-block` 명령어에 `--prev-randao` 옵션이 존재하는데, 이는 수동으로 블록을 구성할 때 prev_randao 값을 지정하기 위함입니다. 해당 도움말에서는 "the prev_randao field replaces the ..."라고 설명하고 있어, prev_randao 필드가 과거 difficulty를 대체한다는 뉘앙스를 주고 있습니다.

Reth는 **엔진 API** 상에서 Beacon 노드로부터 새 블록 빌드 요청을 받을 때 (`engine_forkchoiceUpdatedV2`의 payloadAttributes 혹은 `engine_getPayload` 호출), 전달된 `prevRandao` 값을 **블록 헤더 구조체의 prev_randao 필드**에 채워 넣습니다. 이 헤더는 이후 REVM 실행 시 컨텍스트로 전달되며, REVM (Rust Ethereum Virtual Machine) 자체가 EIP-4399을 반영하여 **opcode 0x44에 대해 주어진 prev_randao를 반환**하도록 구현되어 있습니다. (REVM은 Ethereum Foundation의 `ethereum-specs`를 따라 만들어졌고, PREVRANDAO를 지원합니다.)

Reth 내부적으로 prev_randao는 `Header` 구조체에 별도 필드로 존재하며, JSON-RPC로 블록 조회 시에도 `prevRandao`로 표시됩니다 (일부 Ethereum 클라이언트는 RPC 출력에 mixHash 대신 prevRandao를 노출함). 예를 들어 Reth의 `eth_getBlockByNumber` 반환 객체는 Go-ethereum와 동일한 필드 구성을 가지되, mixHash 대신 prevRandao 필드명을 채택했을 수 있습니다. (공식 JSON-RPC 사양에서는 Shanghai 포크 이후 `mixHash`를 `prevRandao`로 명명하도록 권고함).

**Randao 검증** 측면에서, Reth 실행 클라이언트도 Geth처럼 해당 값의 진위 여부를 스스로 판단하지 않습니다. 대신 **컨센서스 클라이언트가 전달한 값**을 그대로 사용합니다. 다만 Reth는 만약 auto-seal 모드로 동작하며 컨센서스 레이어가 없을 경우, **자체적으로 Randao 값을 만들어야** 합니다. 이 때 Reth는 단순히 직전 블록의 prev_randao를 사용하거나 임의의 난수값을 넣을 가능성이 있습니다. (auto-seal은 하나의 노드이므로 난수 소스가 크게 중요하지 않으며, Reth 문서 상 `--auto-mine` 시에도 prevRandao 관련 언급은 특별히 없지만, CLI로 수동 생성 시 prev-randao를 요구하는 것으로 보아 기본값은 0x0...0 등으로 채울 수 있습니다.)

결국 **Reth의 Randao 로직**은 Geth와 거의 동일한 기능을 수행합니다:

- **블록 헤더**: prev_randao 필드에 Beacon 난수 저장 (또는 auto-seal 시 임의값).
- **EVM**: PREVRANDAO opcode 지원 – REVM이 header.prev_randao를 반환하도록 구현.
- **RPC**: Block 객체에 `prevRandao`를 노출 (사용자들이 난수값을 조회 가능).
- **검증**: 난이도 필드는 0이어야 하고, prev_randao 필드는 PoS 블록에서 필수. Reth header 검증기(`HeaderValidator`)가 이러한 규칙을 체크할 것입니다.

한 가지 부연하면, 이 Randao 값은 **컨트랙트 개발자에게 새로운 난수원**을 제공합니다. Paradigm의 블로그나 미디엄 글 등을 보면, `block.prevrandao`가 `blockhash` 대비 얼마나 개선된 난수원인지, 그러나 여전히 완전 안전하지는 않은지 논의가 있습니다. Reth는 이러한 맥락에서 PREVRANDAO를 정확히 구현함으로써 이더리움 프로토콜 사양을 준수합니다.

마지막으로, Randao와 관련하여 Reth와 Geth 모두 **상호운용성을 갖추고 있음**을 확인할 수 있습니다. 즉, 어느 실행 클라이언트든 블록 헤더의 해당 필드에 동일한 Beacon 난수를 담고, EVM opcode를 동일하게 처리하므로, 컨센서스 클라이언트 입장에서도 Execution Client 교체에 따른 차이가 없습니다.

## 4. Geth vs Reth: 구조상의 차이점과 공통점 요약

**Go-ethereum (Geth)**과 **Reth**는 모두 **이더리움 실행 클라이언트**로서 PoS 합의 프로토콜을 지원하지만, 구현 구조와 세부 방식에서 몇 가지 차이점이 있습니다. 마지막으로 양측의 공통점과 상이점을 정리합니다:

- **엔진 API 구현**: 두 클라이언트 모두 JSON-RPC 기반의 Engine API (`engine_...` 메서드들)를 구현하여 **컨센서스 레이어**와 통신합니다. Geth는 Go 코드의 `eth/catalyst` 패키지에 이를 포함하고 있고, Reth는 Rust의 `rpc-engine-api` 모듈로 분리해 둔 것이 차이입니다. 기능적으로는 `ForkchoiceUpdated`, `NewPayload`, `GetPayload` 등을 처리하며, **컨센서스->실행 지시를 수행**하는 역할은 동일합니다.

- **포크 선택 및 체인관리 구조**: Geth는 전통적으로 단일 쓰레드 동기 방식으로 **BlockChain 구조체**와 **ForkChoice 도우미**를 사용해 체인을 관리합니다. 이에 비해 Reth는 **비동기/병렬 처리**를 염두에 두고 **BlockchainTree** 등의 구조로 체인 분기를 관리합니다. Reth의 blockchain-tree는 여러 포크를 명시적으로 다루며, Tokio task 간 메시지 전달로 헤드 변경을 처리하는 등 **모듈화**되어 있습니다. Geth는 PoW 시절의 설계를 연장하여 ForkChoice.ReorgNeeded로 단순히 필요 여부를 판단하고, BlockChain 내부에서 재구성을 수행하는 **일체형 설계**입니다. 따라서 **Reth는 구조적으로 더 분리되어 있고 테스트하기 쉽게** 구성된 반면, Geth는 **검증된 단순 구조로 안정성**을 확보했다고 볼 수 있습니다.

- **최종화/안전 블록 관리**: 양쪽 다 **최종화(finalized) 블록**과 **안전(safe) 블록** 개념을 도입하여 Chain 상태를 추적합니다. Geth는 `currentFinalBlock`/`currentSafeBlock`을 메모리와 DB에 저장하고, Reth도 `set_finalized`/`finalized_block_hash` 등을 통해 동일 개념을 관리합니다. 두 클라이언트 모두 이 정보를 이용해 **재구성 한계**를 설정하고 **체인 정리(pruning)**에 활용합니다. 구현 언어만 다를 뿐, **Beacon 체인 스펙 준수 측면에서는 동일한 기능**입니다.

- **에포크/슬롯 인지도**: Geth와 Reth 모두 **슬롯/에포크 번호를 직접 계산하거나 추적하지는 않으며**, Beacon 노드가 주는 정보만 사용합니다. 즉, **타임스탬프 검증**(슬롯 간격 보장)과 **최종화 이벤트 처리**(에포크 단위 체크포인트)로 간접적인 인지만 합니다. 이는 Execution Client의 범위가 Beacon chain의 자세한 내용을 갖지 않도록 설계된 프로토콜 분리 원칙에 따른 것입니다.

- **RANDAO(Randomness)**: 두 구현 모두 **Merge 이후 규칙**을 따라 **헤더의 mixHash 필드를 prevRandao로 사용**하고, **난이도 필드는 0으로 고정**합니다. 또 EVM의 `PREVRANDAO(0x44)` 연산을 지원합니다. Geth는 Go EVM에서 이를 처리하고, Reth는 REVM/또는 자체 EVM wrapper에서 처리합니다. 결과적으로 **컨트랙트 레벨 동작은 양쪽이 동일**합니다. 구현상 차이라면, Geth는 기존 `mixDigest` 필드 재사용이라는 내부 구현 용어를 계속 쓰는 반면, Reth는 아예 `prev_randao`라는 명칭으로 필드를 두고 있는 정도입니다. 또한 Reth CLI에서 debug 툴로 prev-randao를 받는 등, Reth 쪽이 용어적으로 최신 스펙을 그대로 반영합니다.

- **언어 및 모듈화 차이**: Go로 작성된 Geth는 단일 바이너리 내에 모든 기능을 포함하며 (합의 엔진 부분은 `consensus/beacon` 패키지 등), Reth는 Rust의 Cargo 크레이트 구조로 `consensus`, `execution`, `network`, `provider` 등이 나뉘어 있습니다. 예컨대 Reth는 네트워크 (P2P)와 실행, 저장소가 모두 개별 모듈이라 테스트와 대체가 용이합니다. Geth는 오래된 코드베이스답게 monolithic 경향이 있으나, Merge를 계기로 catalyst 등 모듈을 추가하여 어느정도 현대화하였습니다.

- **공통점**:

  - 둘 다 **컨센서스 클라이언트 없이는 완전한 메인넷 검증을 할 수 없고**, Beacon 노드와 짝지어 동작합니다. (단, 둘 다 개발/테스트 모드로 자체 합의 생산은 가능).
  - **트랜잭션 풀, EVM, 상태 DB 등 실행층 기본 기능은 동일**하게 갖추고 있으며, PoS 전환으로 인한 변화 (예: 블록 구조 변경, 블록 보상 제거, Withdrawals 처리 등)들을 구현했습니다. 예를 들어 **검증인 출금(Withdrawals)** 기능도 Shanghai/Capella 업그레이드 때 실행층에 추가되었는데, Geth는 `Finalize` 단계에서 출금을 처리하도록 `consensus/beacon`에 구현했고, Reth도 이에 대응하는 처리를 `consensus::beacon` 모듈에 넣었습니다.
  - **성능 측면**에서는 PoS로의 전환 후 실행 클라이언트의 부담이 다소 줄어든 공통 상황이 있습니다. 두 구현 모두 머지 이후 블록 처리가 더 단순해져 (난이도 연산 제거 등) 코드 복잡도가 줄었습니다.

- **차이점 요약**:

  - Geth: **검증된 안정성**, 다년간의 메인넷 운영 실적. 구조는 상대적으로 **일체화**되어 있고, Go 특유의 간결함으로 구현. PoS 관련 코드는 기존 PoW엔진 인터페이스를 확장하여 **BeaconConsensus** 엔진으로 부분 구현 (필요 최소한의 합의 체크만).
  - Reth: **모듈화와 신기술** 강조. Rust의 강점(메모리 안전, 병행성)을 살린 구조로 **병렬 동기화** 등의 이점을 노림. 아직 메인넷에서 Geth만큼 검증되지는 않았으나 Paradigm 주도로 활발히 개발 중.

결론적으로, **양쪽 클라이언트 모두 이더리움의 최신 PoS 프로토콜(Beacon Chain 사양)을 충실히 구현**하고 있으며, **엔진 API를 통한 컨센서스-실행 분리 아키텍처**를 따르고 있습니다. 세부 구현은 언어와 설계철학에 따라 다르지만, **궁극적으로 제공하는 기능과 프로토콜 준수 면에서는 동등한 목적**을 이룹니다. PoS 이더리움의 성공적인 운영은 이러한 다양한 클라이언트들의 협업 덕분이며, Geth와 Reth는 그중 각각 고전과 신예로서 중요한 역할을 수행하고 있습니다.
